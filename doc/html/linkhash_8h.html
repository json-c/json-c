<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>json-c: linkhash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">json-c
   &#160;<span id="projectnumber">0.17</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linkhash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal methods for working with json_type_object objects. Although this is exposed by the <a class="el" href="json__object_8h.html#a2caa52ae1863bd073444f3737138a4db">json_object_get_object()</a> function and within the <a class="el" href="structjson__object__iter.html">json_object_iter</a> type, it is not recommended for direct use.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlh__entry.html">lh_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlh__table.html">lh_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a032f1bd115df254dda325437203ce5fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a032f1bd115df254dda325437203ce5fb">LH_PRIME</a>&#160;&#160;&#160;0x9e370001UL</td></tr>
<tr class="separator:a032f1bd115df254dda325437203ce5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b61772c29d85eb52b697e0b0dc0aaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a66b61772c29d85eb52b697e0b0dc0aaf">LH_LOAD_FACTOR</a>&#160;&#160;&#160;0.66</td></tr>
<tr class="separator:a66b61772c29d85eb52b697e0b0dc0aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fad7f8ae44575dc89c9567859972d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a93fad7f8ae44575dc89c9567859972d2">LH_EMPTY</a>&#160;&#160;&#160;(void *)-1</td></tr>
<tr class="separator:a93fad7f8ae44575dc89c9567859972d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69428f2de0a6fb080b6fb373d506aa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ac69428f2de0a6fb080b6fb373d506aa7">LH_FREED</a>&#160;&#160;&#160;(void *)-2</td></tr>
<tr class="separator:ac69428f2de0a6fb080b6fb373d506aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e80138c5be6dd9b0483a9cbcc8799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ac32e80138c5be6dd9b0483a9cbcc8799">JSON_C_STR_HASH_DFLT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac32e80138c5be6dd9b0483a9cbcc8799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62316f34fd42941b97a8e9a6b6e68faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a62316f34fd42941b97a8e9a6b6e68faa">JSON_C_STR_HASH_PERLLIKE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a62316f34fd42941b97a8e9a6b6e68faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dd67da915065dce2c6f44cb03e2d82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ad7dd67da915065dce2c6f44cb03e2d82">lh_foreach</a>(table, entry)&#160;&#160;&#160;for (entry = <a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head</a>(table); entry; entry = <a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next</a>(entry))</td></tr>
<tr class="separator:ad7dd67da915065dce2c6f44cb03e2d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbb0df08b4976d0649b826b6bacfca1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#abcbb0df08b4976d0649b826b6bacfca1">lh_foreach_safe</a>(table, entry, tmp)&#160;&#160;&#160;for (entry = <a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head</a>(table); entry &amp;&amp; ((tmp = <a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next</a>(entry)) || 1); entry = tmp)</td></tr>
<tr class="separator:abcbb0df08b4976d0649b826b6bacfca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a671553d0ee3c2a123190ba0f8ed2b635"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> )(struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:a671553d0ee3c2a123190ba0f8ed2b635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bae27995dcfb6ee3fb109a9be229b2"><td class="memItemLeft" align="right" valign="top">typedef unsigned long(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a38bae27995dcfb6ee3fb109a9be229b2">lh_hash_fn</a> )(const void *k)</td></tr>
<tr class="separator:a38bae27995dcfb6ee3fb109a9be229b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fd85fc81b0c7c83c62f00e84729091"><td class="memItemLeft" align="right" valign="top">typedef int(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a91fd85fc81b0c7c83c62f00e84729091">lh_equal_fn</a> )(const void *k1, const void *k2)</td></tr>
<tr class="separator:a91fd85fc81b0c7c83c62f00e84729091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766e90057496fc6712d6be0da180a21f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlh__table.html">lh_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a766e90057496fc6712d6be0da180a21f">lh_table</a></td></tr>
<tr class="separator:a766e90057496fc6712d6be0da180a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8e1d61af44d9c0824d8c7980385bcd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ac8e1d61af44d9c0824d8c7980385bcd3">json_global_set_string_hash</a> (const int h)</td></tr>
<tr class="separator:ac8e1d61af44d9c0824d8c7980385bcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4f8a71dbe4d3390d9f7adb331beb0e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a9c4f8a71dbe4d3390d9f7adb331beb0e">lh_table_new</a> (int size, <a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *free_fn, <a class="el" href="linkhash_8h.html#a38bae27995dcfb6ee3fb109a9be229b2">lh_hash_fn</a> *hash_fn, <a class="el" href="linkhash_8h.html#a91fd85fc81b0c7c83c62f00e84729091">lh_equal_fn</a> *equal_fn)</td></tr>
<tr class="separator:a9c4f8a71dbe4d3390d9f7adb331beb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf630754affe92612639542a6c49c3f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a6bf630754affe92612639542a6c49c3f">lh_kchar_table_new</a> (int size, <a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *free_fn)</td></tr>
<tr class="separator:a6bf630754affe92612639542a6c49c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8108563b961dbf5471fe2c0e51f40a5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#af8108563b961dbf5471fe2c0e51f40a5">lh_kptr_table_new</a> (int size, <a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *free_fn)</td></tr>
<tr class="separator:af8108563b961dbf5471fe2c0e51f40a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81653acf740cf8c9fe672e6cd16df0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a81653acf740cf8c9fe672e6cd16df0cf">lh_table_free</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="separator:a81653acf740cf8c9fe672e6cd16df0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c0cd547be1e2c2486a73bd58e1352c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a86c0cd547be1e2c2486a73bd58e1352c">lh_table_insert</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const void *v)</td></tr>
<tr class="separator:a86c0cd547be1e2c2486a73bd58e1352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4558a9347a422e03a15b0b7a29b82dc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a4558a9347a422e03a15b0b7a29b82dc3">lh_table_insert_w_hash</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const void *v, const unsigned long h, const unsigned opts)</td></tr>
<tr class="separator:a4558a9347a422e03a15b0b7a29b82dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b6ca2d967a6c3021ee6c39e014a918"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ad3b6ca2d967a6c3021ee6c39e014a918">lh_table_lookup_entry</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="separator:ad3b6ca2d967a6c3021ee6c39e014a918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ecaf34ef59280952f4459b2de63677"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a59ecaf34ef59280952f4459b2de63677">lh_table_lookup_entry_w_hash</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const unsigned long h)</td></tr>
<tr class="separator:a59ecaf34ef59280952f4459b2de63677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c270bb0dd9d5c8a3e7ae20bc4d67f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json__types_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a81c270bb0dd9d5c8a3e7ae20bc4d67f3">lh_table_lookup_ex</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, void **v)</td></tr>
<tr class="separator:a81c270bb0dd9d5c8a3e7ae20bc4d67f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5885a71c3457190fb1dc2d6e20dde3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ae5885a71c3457190fb1dc2d6e20dde3b">lh_table_delete_entry</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:ae5885a71c3457190fb1dc2d6e20dde3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fed2c78f70d229edb2d00775ffe593c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a2fed2c78f70d229edb2d00775ffe593c">lh_table_delete</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="separator:a2fed2c78f70d229edb2d00775ffe593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ba631c91fe80fb905f04c7cd526f2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ac9ba631c91fe80fb905f04c7cd526f2b">lh_table_length</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="separator:ac9ba631c91fe80fb905f04c7cd526f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c8414e31aeee7669acc938116d933f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a30c8414e31aeee7669acc938116d933f">lh_table_resize</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, int new_size)</td></tr>
<tr class="separator:a30c8414e31aeee7669acc938116d933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bacf1f7c40830c20440fd95d493f35f"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head</a> (const <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="separator:a3bacf1f7c40830c20440fd95d493f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c74c884530d407d0b3baa365238fb4"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a33c74c884530d407d0b3baa365238fb4">lh_get_hash</a> (const struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="separator:a33c74c884530d407d0b3baa365238fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e5d699ba2fd4c520352c003f8554a5"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a82e5d699ba2fd4c520352c003f8554a5">lh_entry_k</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:a82e5d699ba2fd4c520352c003f8554a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724c308f1c606271ea3deb01ed9e3cc9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a724c308f1c606271ea3deb01ed9e3cc9">lh_entry_k_is_constant</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:a724c308f1c606271ea3deb01ed9e3cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab163f65568af863f3738ccd05900745e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ab163f65568af863f3738ccd05900745e">lh_entry_v</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:ab163f65568af863f3738ccd05900745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e87a8ef92ee6371e5314b7241e635"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#ad94e87a8ef92ee6371e5314b7241e635">lh_entry_set_val</a> (struct <a class="el" href="structlh__entry.html">lh_entry</a> *e, void *newval)</td></tr>
<tr class="separator:ad94e87a8ef92ee6371e5314b7241e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f6f2cc6d292a160b09b357c7a0a69"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:a603f6f2cc6d292a160b09b357c7a0a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965145d36d3e00eae825c692205d2f81"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linkhash_8h.html#a965145d36d3e00eae825c692205d2f81">lh_entry_prev</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="separator:a965145d36d3e00eae825c692205d2f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal methods for working with json_type_object objects. Although this is exposed by the <a class="el" href="json__object_8h.html#a2caa52ae1863bd073444f3737138a4db">json_object_get_object()</a> function and within the <a class="el" href="structjson__object__iter.html">json_object_iter</a> type, it is not recommended for direct use. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac32e80138c5be6dd9b0483a9cbcc8799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JSON_C_STR_HASH_DFLT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>default string hash function </p>

</div>
</div>
<a class="anchor" id="a62316f34fd42941b97a8e9a6b6e68faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JSON_C_STR_HASH_PERLLIKE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>perl-like string hash function </p>

</div>
</div>
<a class="anchor" id="a93fad7f8ae44575dc89c9567859972d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_EMPTY&#160;&#160;&#160;(void *)-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sentinel pointer value for empty slots </p>

</div>
</div>
<a class="anchor" id="ad7dd67da915065dce2c6f44cb03e2d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lh_foreach</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;for (entry = <a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head</a>(table); entry; entry = <a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next</a>(entry))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience list iterator. </p>

</div>
</div>
<a class="anchor" id="abcbb0df08b4976d0649b826b6bacfca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lh_foreach_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tmp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;for (entry = <a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head</a>(table); entry &amp;&amp; ((tmp = <a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next</a>(entry)) || 1); entry = tmp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lh_foreach_safe allows calling of deletion routine while iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>a struct <a class="el" href="structlh__table.html">lh_table</a> * to iterate over </td></tr>
    <tr><td class="paramname">entry</td><td>a struct <a class="el" href="structlh__entry.html">lh_entry</a> * variable to hold each element </td></tr>
    <tr><td class="paramname">tmp</td><td>a struct <a class="el" href="structlh__entry.html">lh_entry</a> * variable to hold a temporary pointer to the next element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac69428f2de0a6fb080b6fb373d506aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_FREED&#160;&#160;&#160;(void *)-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sentinel pointer value for freed slots </p>

</div>
</div>
<a class="anchor" id="a66b61772c29d85eb52b697e0b0dc0aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_LOAD_FACTOR&#160;&#160;&#160;0.66</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The fraction of filled hash buckets until an insert will cause the table to be resized. This can range from just above 0 up to 1.0. </p>

</div>
</div>
<a class="anchor" id="a032f1bd115df254dda325437203ce5fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_PRIME&#160;&#160;&#160;0x9e370001UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>golden prime used in hash functions </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a671553d0ee3c2a123190ba0f8ed2b635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( lh_entry_free_fn)(struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a class="anchor" id="a91fd85fc81b0c7c83c62f00e84729091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( lh_equal_fn)(const void *k1, const void *k2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a class="anchor" id="a38bae27995dcfb6ee3fb109a9be229b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long( lh_hash_fn)(const void *k)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a class="anchor" id="a766e90057496fc6712d6be0da180a21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlh__table.html">lh_table</a> <a class="el" href="structlh__table.html">lh_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac8e1d61af44d9c0824d8c7980385bcd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int json_global_set_string_hash </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the hash function to be used for strings. Must be one of the JSON_C_STR_HASH_* values. </p>
<dl class="section return"><dt>Returns</dt><dd>0 - ok, -1 if parameter was invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a82e5d699ba2fd4c520352c003f8554a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* lh_entry_k </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a non-const version of <a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry.k</a>.</p>
<p><a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry.k</a> is const to indicate and help ensure that linkhash itself doesn't modify it, but callers are allowed to do what they want with it. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="linkhash_8h.html#a724c308f1c606271ea3deb01ed9e3cc9">lh_entry_k_is_constant()</a> </dd></dl>

<p>References <a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry::k</a>.</p>

</div>
</div>
<a class="anchor" id="a724c308f1c606271ea3deb01ed9e3cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lh_entry_k_is_constant </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns 1 if the key for the given entry is constant, and thus does not need to be freed when the <a class="el" href="structlh__entry.html">lh_entry</a> is freed. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="linkhash_8h.html#a4558a9347a422e03a15b0b7a29b82dc3">lh_table_insert_w_hash()</a> </dd></dl>

<p>References <a class="el" href="structlh__entry.html#a14f40cc124c32b03f81151ae7934d2e7">lh_entry::k_is_constant</a>.</p>

</div>
</div>
<a class="anchor" id="a603f6f2cc6d292a160b09b357c7a0a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structlh__entry.html">lh_entry</a>* lh_entry_next </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next element, or NULL if there is no next element. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head()</a> </dd>
<dd>
<a class="el" href="linkhash_8h.html#a965145d36d3e00eae825c692205d2f81">lh_entry_prev()</a> </dd></dl>

<p>References <a class="el" href="structlh__entry.html#a7c40c46e72d9a0ba071a8d49d535bc67">lh_entry::next</a>.</p>

</div>
</div>
<a class="anchor" id="a965145d36d3e00eae825c692205d2f81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structlh__entry.html">lh_entry</a>* lh_entry_prev </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the previous element, or NULL if there is no previous element. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="linkhash_8h.html#a3bacf1f7c40830c20440fd95d493f35f">lh_table_head()</a> </dd>
<dd>
<a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next()</a> </dd></dl>

<p>References <a class="el" href="structlh__entry.html#a6fb9c3de01fb5af67d8d429921cc6a3b">lh_entry::prev</a>.</p>

</div>
</div>
<a class="anchor" id="ad94e87a8ef92ee6371e5314b7241e635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lh_entry_set_val </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value for an entry. The caller is responsible for freeing the previous value. </p>

<p>References <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry::v</a>.</p>

</div>
</div>
<a class="anchor" id="ab163f65568af863f3738ccd05900745e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* lh_entry_v </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a non-const version of <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry.v</a>.</p>
<p>v is const to indicate and help ensure that linkhash itself doesn't modify it, but callers are allowed to do what they want with it. </p>

<p>References <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry::v</a>.</p>

</div>
</div>
<a class="anchor" id="a33c74c884530d407d0b3baa365238fb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long lh_get_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the hash of a key for a given table.</p>
<p>This is an extension to support functions that need to calculate the hash several times and allows them to do it just once and then pass in the hash to all utility functions. Depending on use case, this can be a considerable performance improvement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table (used to obtain hash function) </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the key's hash </dd></dl>

<p>References <a class="el" href="structlh__table.html#a1488d1a4a320b1a9bb2f441859544be1">lh_table::hash_fn</a>.</p>

</div>
</div>
<a class="anchor" id="a6bf630754affe92612639542a6c49c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a>* lh_kchar_table_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *&#160;</td>
          <td class="paramname"><em>free_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to create a new linkhash table with char keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af8108563b961dbf5471fe2c0e51f40a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a>* lh_kptr_table_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *&#160;</td>
          <td class="paramname"><em>free_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to create a new linkhash table with ptr keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fed2c78f70d229edb2d00775ffe593c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a record from the table.</p>
<p>If a callback free function is provided then it is called for the for the item being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to delete from. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the item was deleted. </dd>
<dd>
-1 if it was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5885a71c3457190fb1dc2d6e20dde3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_delete_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a record from the table.</p>
<p>If a callback free function is provided then it is called for the for the item being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to delete from. </td></tr>
    <tr><td class="paramname">e</td><td>a pointer to the entry to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the item was deleted. </dd>
<dd>
-1 if it was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a81653acf740cf8c9fe672e6cd16df0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lh_table_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a linkhash table.</p>
<p>If a lh_entry_free_fn callback free function was provided then it is called for all entries in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>table to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bacf1f7c40830c20440fd95d493f35f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structlh__entry.html">lh_entry</a>* lh_table_head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first entry in the <a class="el" href="structlh__table.html">lh_table</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="linkhash_8h.html#a603f6f2cc6d292a160b09b357c7a0a69">lh_entry_next()</a> </dd></dl>

<p>References <a class="el" href="structlh__table.html#aa7d986a3b12a9fa47e349713794c30fb">lh_table::head</a>.</p>

</div>
</div>
<a class="anchor" id="a86c0cd547be1e2c2486a73bd58e1352c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a record into the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to insert into. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to insert. </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to the value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>0</code> is returned. On error, a negative value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a4558a9347a422e03a15b0b7a29b82dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_insert_w_hash </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a record into the table using a precalculated key hash.</p>
<p>The hash h, which should be calculated with <a class="el" href="linkhash_8h.html#a33c74c884530d407d0b3baa365238fb4">lh_get_hash()</a> on k, is provided by the caller, to allow for optimization when multiple operations with the same key are known to be needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to insert into. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to insert. </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to the value to insert. </td></tr>
    <tr><td class="paramname">h</td><td>hash value of the key to insert </td></tr>
    <tr><td class="paramname">opts</td><td>if set to JSON_C_OBJECT_ADD_CONSTANT_KEY, sets <a class="el" href="structlh__entry.html#a14f40cc124c32b03f81151ae7934d2e7">lh_entry.k_is_constant</a> so t's free function knows to avoid freeing the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9ba631c91fe80fb905f04c7cd526f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in the table. </p>

</div>
</div>
<a class="anchor" id="ad3b6ca2d967a6c3021ee6c39e014a918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a>* lh_table_lookup_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup a record in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the record structure of the value or NULL if it does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a59ecaf34ef59280952f4459b2de63677"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a>* lh_table_lookup_entry_w_hash </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup a record in the table using a precalculated key hash.</p>
<p>The hash h, which should be calculated with <a class="el" href="linkhash_8h.html#a33c74c884530d407d0b3baa365238fb4">lh_get_hash()</a> on k, is provided by the caller, to allow for optimization when multiple operations with the same key are known to be needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
    <tr><td class="paramname">h</td><td>hash value of the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the record structure of the value or NULL if it does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a81c270bb0dd9d5c8a3e7ae20bc4d67f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json__types_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a> lh_table_lookup_ex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup a record in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to a where to store the found value (set to NULL if it doesn't exist). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the key was found </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4f8a71dbe4d3390d9f7adb331beb0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a>* lh_table_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linkhash_8h.html#a671553d0ee3c2a123190ba0f8ed2b635">lh_entry_free_fn</a> *&#160;</td>
          <td class="paramname"><em>free_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linkhash_8h.html#a38bae27995dcfb6ee3fb109a9be229b2">lh_hash_fn</a> *&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linkhash_8h.html#a91fd85fc81b0c7c83c62f00e84729091">lh_equal_fn</a> *&#160;</td>
          <td class="paramname"><em>equal_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new linkhash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. The table is automatically resized although this incurs a performance penalty. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries when lh_table_free or lh_table_delete is called. If NULL is provided, then memory for keys and values must be freed by the caller. </td></tr>
    <tr><td class="paramname">hash_fn</td><td>function used to hash keys. 2 standard ones are defined: lh_ptr_hash and lh_char_hash for hashing pointer values and C strings respectively. </td></tr>
    <tr><td class="paramname">equal_fn</td><td>comparison function to compare keys. 2 standard ones defined: lh_ptr_hash and lh_char_hash for comparing pointer values and C strings respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a30c8414e31aeee7669acc938116d933f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_resize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes the specified table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Pointer to table to resize. </td></tr>
    <tr><td class="paramname">new_size</td><td>New table size. Must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>0</code> is returned. On error, a negative value is returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 12 2023 18:59:55 for json-c by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
